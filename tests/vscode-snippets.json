{
  "Test Utils Imports": {
    "prefix": "test-imports",
    "body": [
      "import { screen, waitFor } from '@testing-library/react';",
      "import userEvent from '@testing-library/user-event';",
      "import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';",
      "import { renderWithQuery, createTestQueryClient } from '@/test-utils/react-query-helpers';",
      "import { mockAxiosGet, mockAxiosPost, clearAxiosMocks } from '@/test-utils/axios-mock-helpers';",
      "import { waitForLoadingToFinish, flushPromises } from '@/test-utils/async-test-helpers';"
    ],
    "description": "Import test utilities"
  },

  "Basic Test Structure": {
    "prefix": "test-structure",
    "body": [
      "describe('${1:ComponentName}', () => {",
      "  afterEach(() => {",
      "    clearAxiosMocks();",
      "  });",
      "",
      "  it('should ${2:do something}', async () => {",
      "    // Setup",
      "    mockAxiosGet('${3:/api/endpoint}', ${4:mockData});",
      "    const user = userEvent.setup();",
      "    const queryClient = createTestQueryClient();",
      "",
      "    // Render",
      "    renderWithQuery(<${1:ComponentName} />, { queryClient });",
      "",
      "    // Wait for loading",
      "    await waitForLoadingToFinish(() => screen.queryByTestId('loader'));",
      "",
      "    // Interact",
      "    await user.click(screen.getByText('${5:Button}'));",
      "",
      "    // Assert",
      "    await waitFor(() => {",
      "      expect(screen.getByText('${6:Expected}')).toBeInTheDocument();",
      "    });",
      "  });",
      "});"
    ],
    "description": "Basic test structure with utilities"
  },

  "Mock Axios GET": {
    "prefix": "mock-get",
    "body": [
      "mockAxiosGet('${1:/api/endpoint}', ${2:mockData});"
    ],
    "description": "Mock axios GET request"
  },

  "Mock Axios POST": {
    "prefix": "mock-post",
    "body": [
      "mockAxiosPost('${1:/api/endpoint}', ${2:responseData});"
    ],
    "description": "Mock axios POST request"
  },

  "Mock Axios PUT": {
    "prefix": "mock-put",
    "body": [
      "mockAxiosPut('${1:/api/endpoint}', ${2:responseData});"
    ],
    "description": "Mock axios PUT request"
  },

  "Mock Axios DELETE": {
    "prefix": "mock-delete",
    "body": [
      "mockAxiosDelete('${1:/api/endpoint}', ${2:responseData});"
    ],
    "description": "Mock axios DELETE request"
  },

  "Mock Axios Error": {
    "prefix": "mock-error",
    "body": [
      "mockAxiosError('${1:get}', '${2:/api/endpoint}', '${3:Error message}', ${4:500});"
    ],
    "description": "Mock axios error response"
  },

  "Mock Axios Timeout": {
    "prefix": "mock-timeout",
    "body": [
      "mockAxiosTimeout('${1:get}', '${2:/api/endpoint}');"
    ],
    "description": "Mock axios timeout"
  },

  "Mock Axios Unauthorized": {
    "prefix": "mock-unauth",
    "body": [
      "mockAxiosUnauthorized('${1:get}', '${2:/api/endpoint}');"
    ],
    "description": "Mock 401 unauthorized response"
  },

  "Mock Axios Sequence": {
    "prefix": "mock-sequence",
    "body": [
      "mockAxiosSequence('${1:get}', '${2:/api/endpoint}', [",
      "  { error: '${3:First failure}' },",
      "  { error: '${4:Second failure}' },",
      "  { data: ${5:successData} }",
      "]);"
    ],
    "description": "Mock axios with retry sequence"
  },

  "Render with Query": {
    "prefix": "render-query",
    "body": [
      "const queryClient = createTestQueryClient();",
      "renderWithQuery(<${1:Component} ${2:props} />, { queryClient });"
    ],
    "description": "Render component with QueryClient"
  },

  "Create QueryClient": {
    "prefix": "query-client",
    "body": [
      "const queryClient = createTestQueryClient();"
    ],
    "description": "Create test QueryClient"
  },

  "Mock Query Success": {
    "prefix": "mock-query-success",
    "body": [
      "mockQuerySuccess(queryClient, [${1:'queryKey'}], ${2:mockData});"
    ],
    "description": "Mock successful query"
  },

  "Mock Query Error": {
    "prefix": "mock-query-error",
    "body": [
      "mockQueryError(queryClient, [${1:'queryKey'}], new Error('${2:Error message}'));"
    ],
    "description": "Mock query error"
  },

  "Mock Query Loading": {
    "prefix": "mock-query-loading",
    "body": [
      "mockQueryLoading(queryClient, [${1:'queryKey'}]);"
    ],
    "description": "Mock loading query"
  },

  "Wait for Loading": {
    "prefix": "wait-loading",
    "body": [
      "await waitForLoadingToFinish(() => screen.queryByTestId('${1:loader}') as HTMLElement | null);"
    ],
    "description": "Wait for loading to finish"
  },

  "Flush Promises": {
    "prefix": "flush-promises",
    "body": [
      "await flushPromises();"
    ],
    "description": "Flush all pending promises"
  },

  "Wait for Async": {
    "prefix": "wait-async",
    "body": [
      "await waitForAsync(() => ${1:operation});"
    ],
    "description": "Wait for async operation"
  },

  "User Event Setup": {
    "prefix": "user-setup",
    "body": [
      "const user = userEvent.setup();"
    ],
    "description": "Setup userEvent"
  },

  "User Click": {
    "prefix": "user-click",
    "body": [
      "await user.click(screen.getBy${1:Text}('${2:Button}'));"
    ],
    "description": "User click event"
  },

  "User Type": {
    "prefix": "user-type",
    "body": [
      "await user.type(screen.getBy${1:LabelText}('${2:Field}'), '${3:value}');"
    ],
    "description": "User type event"
  },

  "User Clear": {
    "prefix": "user-clear",
    "body": [
      "await user.clear(screen.getBy${1:LabelText}('${2:Field}'));"
    ],
    "description": "User clear input"
  },

  "Cleanup Hook": {
    "prefix": "test-cleanup",
    "body": [
      "afterEach(() => {",
      "  clearAxiosMocks();",
      "});"
    ],
    "description": "Add cleanup hook"
  },

  "Wait For Assertion": {
    "prefix": "wait-for",
    "body": [
      "await waitFor(() => {",
      "  expect(screen.getBy${1:Text}('${2:Text}')).toBeInTheDocument();",
      "});"
    ],
    "description": "Wait for assertion"
  },

  "Deferred Promise": {
    "prefix": "deferred",
    "body": [
      "const deferred = createDeferredPromise<${1:Type}>();",
      "${2:// Use deferred.promise in mock}",
      "deferred.resolve(${3:value});"
    ],
    "description": "Create deferred promise for loading states"
  },

  "Test with Error": {
    "prefix": "test-error",
    "body": [
      "it('should handle ${1:error scenario}', async () => {",
      "  mockAxiosError('${2:get}', '${3:/api/endpoint}', '${4:Error message}', ${5:500});",
      "",
      "  const queryClient = createTestQueryClient();",
      "  renderWithQuery(<${6:Component} />, { queryClient });",
      "",
      "  await waitFor(() => {",
      "    expect(screen.getByText(/error/i)).toBeInTheDocument();",
      "  });",
      "});"
    ],
    "description": "Test error handling"
  },

  "Test with Loading": {
    "prefix": "test-loading",
    "body": [
      "it('should show loading state', async () => {",
      "  const deferred = createDeferredPromise();",
      "  mockAxiosGet('${1:/api/endpoint}', deferred.promise);",
      "",
      "  const queryClient = createTestQueryClient();",
      "  renderWithQuery(<${2:Component} />, { queryClient });",
      "",
      "  expect(screen.getByTestId('${3:loader}')).toBeInTheDocument();",
      "",
      "  deferred.resolve(${4:mockData});",
      "",
      "  await waitForLoadingToFinish(() => screen.queryByTestId('${3:loader}'));",
      "  expect(screen.getByText('${5:Data}')).toBeInTheDocument();",
      "});"
    ],
    "description": "Test loading state"
  },

  "Test Form Submission": {
    "prefix": "test-form",
    "body": [
      "it('should submit form', async () => {",
      "  mockAxiosPost('${1:/api/submit}', ${2:responseData});",
      "",
      "  const user = userEvent.setup();",
      "  const queryClient = createTestQueryClient();",
      "  renderWithQuery(<${3:Form} />, { queryClient });",
      "",
      "  await user.type(screen.getByLabelText('${4:Field}'), '${5:value}');",
      "  await user.click(screen.getByText('${6:Submit}'));",
      "",
      "  await waitFor(() => {",
      "    expect(screen.getByText('${7:Success message}')).toBeInTheDocument();",
      "  });",
      "});"
    ],
    "description": "Test form submission"
  },

  "Mock Multiple Endpoints": {
    "prefix": "mock-multi",
    "body": [
      "mockAxiosGet('${1:/api/endpoint1}', ${2:data1});",
      "mockAxiosGet('${3:/api/endpoint2}', ${4:data2});",
      "mockAxiosGet('${5:/api/endpoint3}', ${6:data3});"
    ],
    "description": "Mock multiple endpoints"
  },

  "Complete Test Template": {
    "prefix": "test-complete",
    "body": [
      "import { screen, waitFor } from '@testing-library/react';",
      "import userEvent from '@testing-library/user-event';",
      "import { describe, it, expect, afterEach } from 'vitest';",
      "import { renderWithQuery, createTestQueryClient } from '@/test-utils/react-query-helpers';",
      "import { mockAxiosGet, clearAxiosMocks } from '@/test-utils/axios-mock-helpers';",
      "",
      "describe('${1:ComponentName}', () => {",
      "  afterEach(() => {",
      "    clearAxiosMocks();",
      "  });",
      "",
      "  it('should ${2:do something}', async () => {",
      "    mockAxiosGet('${3:/api/endpoint}', ${4:mockData});",
      "",
      "    const user = userEvent.setup();",
      "    const queryClient = createTestQueryClient();",
      "    renderWithQuery(<${1:ComponentName} />, { queryClient });",
      "",
      "    await user.click(screen.getByText('${5:Button}'));",
      "",
      "    await waitFor(() => {",
      "      expect(screen.getByText('${6:Expected}')).toBeInTheDocument();",
      "    });",
      "  });",
      "});"
    ],
    "description": "Complete test file template"
  }
}
